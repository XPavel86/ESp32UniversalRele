
 <html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta charset='UTF-8'>

<style>

.modal-footer {
        display: flex;
        justify-content: space-between;
        margin-top: 20px;
    }

    .modal-footer button {
        padding: 10px 20px;
        background-color: #5aafd5;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s ease;
    }

    .modal-footer button:hover {
        background-color: #458dbb;
    }

    .modal-footer button:active {
        background-color: #366b8f;
    }

#addRelayModal {
    z-index: 30; /* Поверх первого модального окна */
}

/* Кнопка с шестеренкой прижата к нижнему правому краю с небольшими сдвигами */
form#formScenario {
  position: relative;
}

.settings-toggle-btn {
  position: absolute;
  bottom: 10px; /* Сдвигаем кнопку вверх от нижнего края */
  right: 10px; /* Сдвигаем кнопку влево от правого края */
  transform: translateY(0); /* Убираем вертикальный сдвиг, так как теперь использован только bottom */
  background: none;
  border: none;
  font-size: 24px;
  cursor: pointer;
  color: #333;
  padding: 10px;
}


.custom-select {
    width: 200px;
    position: relative;
    font-size: 14px;
    border: 1px solid #757575;
    border-radius: 8px;
    background-color: #fff;
    cursor: pointer;
    overflow: visible;
}

.selected-values {
    padding: 8px;
    border-radius: 8px;
    background-color: #E1EAF0;
    color: #333;
}

.options {
    display: none;
    position: absolute;
    top: 100%;
    left: 0;
    width: 100%;
    max-height: 150px;
    overflow-y: auto;
    border: 1px solid #ccc;
    border-radius: 5px;
    background-color: #fff;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    z-index: 10;
    margin-top: 10px;  /* Отступ сверху для отделения от формы */
}

.options label {
    display: block;
    padding: 8px;
    cursor: pointer;
    font-size: 14px;
}

.options label:hover {
    background-color: #f0f0f0;
}

.options input {
    margin-right: 8px; /* уменьшили отступ между чекбоксом и текстом */
}

/* Стиль для занятых пинов */
.option-disabled {
    background-color: #f8d7da !important;  /* Красный фон */
    color: #721c24;  /* Цвет текста */
    pointer-events: none;  /* Отключение возможности взаимодействия с элементом */
}

/* Контейнер для select-элементов на одной строке */
.select-row {
    display: flex;
    align-items: center; /* Выравнивание по вертикали */
    gap: 10px; /* Расстояние между элементами */
}

.checkbox-group {
    display: flex;
    flex-direction: column;
    margin-top: 10px;
}


/* Обертка модального окна */
.modal {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: #E1EAF0; /* Цвет фона, как у body */
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    z-index: 1000;
    max-width: 450px;
    width: 100%;
     overflow: auto; /* Включаем прокрутку при необходимости */
}

/* Обертка модального окна для настроек */
.modal-settings {
    position: relative; /* Убираем фиксированное позиционирование */
    left: 5px; /* Прижимаем к левому краю */
    background-color: #E1EAF0;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
    max-width: 550px;
    width: 100%;
   /* width: fit-content;  Ширина по содержимому */
   /* padding-right: 20px;  Дополнительные 5 пикселей */
    margin-left: 0; /* Прижимаем к левому краю */
    margin-top: 20px; /* Расстояние сверху */
    margin-bottom: 20px; /* Расстояние снизу, чтобы форма не прилипала к следующему элементу */
    height: auto; /* Высота будет зависеть от содержимого */
    min-height: 150px; /* Минимальная высота, чтобы форма не была слишком маленькой */
}


/* Затемнение фона при открытом модальном окне */
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    z-index: 999;
}

/* Заголовок модального окна */
.modal h1, .modal h2 {
    color: #444;
    margin-bottom: 20px;
}

/* Кнопки внутри модального окна */
.modal button {
    font-size: 13px;
    padding: 5px 10px;
    border: 1px solid gray;
    border-radius: 10px;
    background-color: rgba(173, 216, 230, 0.5);
    color: black;
    box-shadow: 0 4px 6px rgba(206, 183, 183, 0.1);
    transition: all 0.3s ease;
    cursor: pointer;
}

.modal button:hover {
    background: linear-gradient(to bottom, #5aafd5, #458dbb);
}

.modal button:active {
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

/* Прокрутка для форм и содержимого */
    form {
        max-height: 70vh; /* Ограничиваем высоту формы */
        overflow-y: auto; /* Вертикальная прокрутка */
    }
    
 /* Стиль для выпадающего списка (select), чтобы он был такого же размера, как input */
select {
    width: 125px; /* Такой же размер как у input[type="text"], можно подогнать под нужную ширину */
    padding: 10px;
    margin-bottom: 10px;
    border: 1px solid #757575;
    border-radius: 10px;
    font-size: 16px;
}

/* Исправление для чекбоксов, чтобы они были на одной строке с лейблами */
.checkbox-container {
    display: flex;
    align-items: center;
    margin-bottom: 10px;
}

.checkbox-container label {
    margin-left: 5px; /* Лейбл находится справа от чекбокса */
    font-size: 16px;
}

.checkbox-container input[type="checkbox"] {
    margin-left: 10px;

}

/* Применение стилей для чекбоксов в модальном окне */
.modal .checkbox-container {
    display: flex;
    align-items: center;
    margin-bottom: 10px;
}

.checkbox-container:hover {
    background-color: #f0f0f0;
}

    body {
        font-family: Arial, sans-serif;
        background-color: #E1EAF0;
        color: #333;
        margin: 0;
        padding: 20px;
    }
    
        #downloadLink {
      display: none;
      margin-top: 10px;
    }
    #copyMessage {
      display: none;
      margin-top: 10px;
      color: green;
    }

    h1,
    h2 {
        color: #444;
    }
    
    #current-value-label {
    transition: top 0.5s, left 0.5s; /* Плавное перемещение лейбла */
	}

    button {
        font-size: 13px;
        padding: 5px 10px;
        /* Отступы внутри кнопки */
        border: 1px solid gray;
        border-radius: 10px;
        background-color: rgba(173, 216, 230, 0.5);
        color: black;
        box-shadow: 0 4px 6px rgba(206, 183, 183, 0.1);
        transition: all 0.3s ease;
        /* Плавное изменение стилей при наведении */
        cursor: pointer;
    }
    
        .relay-row {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
    }
    .relay-description {
    width: fit-content; /* Ширина по содержимому */
    padding-right: 10px; /* Дополнительные 5 пикселей */
    text-align: left;
}
    .relay-controls {
        margin-right: 10px;
    }
    .relay-controls button {
        margin-right: 5px;
    }
    .relay-state, .relay-mode {
        margin-left: 10px;
    }

    input[type="radio"] {
        margin-right: 10px;
    }

    input[type="text"],
    input[type="password"],
    input[type="number"] {
        width: 250px;
        padding: 10px;
        margin-bottom: 10px;
        border: 1px solid #757575;
        border-radius: 10px;
        font-size: 16px;
    }

    /* Унифицированные стили для текстовых полей */
    input[type="text"],
    input[type="number"],
    input[type="date"],
    input[type="time"] {
        border: 1px solid #ccc;
        padding: 5px;
        font-size: 16px;
    }

    label {
        display: block;
        margin-bottom: 5px;
    }

    .tablinks {
        padding: 8px 5px;
        margin-right: 6px;
        background-color: rgba(173, 216, 230, 0.5);
        transition: background-color 0.3s ease;
    }

    .butScan {
        padding: 8px 2px;
        margin-bottom: 8px;
        width: 150px;
        height: 35px;
    }

    .butinput {
        padding: 8px 2px;
        margin-bottom: 8px;
        width: 66px;
        height: 35px;
    }

    .checkbox-container,
    .checkbox-container-inline {
        display: flex;
        align-items: center;
    }

    .turn-off-power-limit .checkbox-container {
        margin-left: auto;
    }

    .checkbox-container {
        display: flex;
        align-items: center;
        margin-left: 10px;
    }

    .checkbox-label-container {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
    }

    .checkbox-container {
        display: flex;
        align-items: center;
    }

    .checkbox-container label {
        margin-left: 5px;
    }

    .checkbox-container input[type="checkbox"] {
        width: 30px;
        height: 30px;
    }

    #imageContainer {
        width: 100%;
        display: flex;
        justify-content: center;
    }

    #squareImage {
        width: 100%;
        height: auto;
        max-width: 100%;
        object-fit: cover;
    }

    .container-TempSmoothly {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
    }

    /* Стили для колибровки */
    /* Стили для контейнера калибровки */
    .calibration-container {
        margin-top: 20px;
    }

    .upper-limit,
    .lower-limit {
        margin-top: 10px;
    }

    .upper-limit label,
    .lower-limit label {
        margin-right: 10px;
    }

    .upper-limit button,
    .lower-limit button {
        margin-right: 5px;
    }

    .calibration-container {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
    }

    .calibration-container label {
        margin-right: 10px;
    }

    #calibrationButton {
        margin-bottom: 10px;
    }

    .upper-limit,
    .lower-limit {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
    }

    .upper-limit button,
    .lower-limit button {
        margin-left: 5px;
    }

    .switch-label {
        margin-left: 10px;
    }
    
.input-group-calibration {
    display: block; /* Изменено с flex на block */
    margin-bottom: 10px;
}

.input-group-calibration label {
    display: block; /* Добавлено для того чтобы label тоже занимал всю ширину своего контейнера */
    margin-bottom: 5px; /* Добавлен отступ снизу для label */
}

.input-group-calibration input[type="number"] {
    width: 100px;
    padding: 5px;
    font-size: 16px;
    border: 1px solid #ccc;
    border-radius: 5px;
    margin-bottom: 10px; /* Добавлен отступ снизу для input */
}

.info-display {
    display: flex;
    flex-direction: column;
}

.info-display label {
    margin: 5px 0;
}

    .input-group-temperature {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
    }

    .input-group-temperature label {
        margin-right: 10px;
    }

    .input-group-temperature input[type="number"] {
        width: 100px;
        padding: 5px;
        font-size: 16px;
        border: 1px solid #ccc;
        border-radius: 5px;
        margin-right: 10px;
    }

    .input-group-temperature input[type="checkbox"] {
        margin-left: 10px;
        margin-right: 5px;
    }

    .radio-container {
        display: flex;
        align-items: center;
        margin-top: 10px;
    }

    .radio-container input[type="radio"] {
        margin-left: 10px;
        margin-right: 5px;
    }

    .radio-container label {
        margin-right: 15px;
    }

    /* Стили для текстовых полей времени */
    input[type="time"] {
        width: 100px;
    }

    .radio-container {
        display: flex;
        align-items: center;
        margin-top: 10px;
    }

    .radio-container input[type="radio"] {
        margin-right: 5px;
    }

    .radio-container label {
        margin-right: 20px;
    }

    .interval-container {
        display: flex;
        flex-direction: column;
    }

    .input-group {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
    }

    .input-group label {
        margin-right: 10px;
    }

    .input-group input[type="checkbox"] {
        margin-left: 10px;
        margin-right: 5px;
    }

    input[type="time"],
    input[type="date"] {
        padding: 5px;
        font-size: 16px;
        border: 1px solid #ccc;
        border-radius: 5px;
        margin-right: 10px;
    }

    /* Стили для слайдера */
    .slider-container input[type="range"] {
        width: 300px;
        display: inline-block;
        margin-right: 10px;
    }

    .slider-container {
        display: flex;
        align-items: center;

    }

    .slider-container input[type="range"] {
        width: 300px;
        display: inline-block;
        width: 380px;
        height: 30px;
    }

    .slider-container label {
        display: flex;
        align-items: center;
        margin-left: 5px;
    }

    .time-container {
        display: flex;
        align-items: left;
        margin-bottom: 10px;
        justify-content: flex-start;

    }

    .time-container label {
        margin-right: 10px;
    }

    .time-container input[type="number"] {
        width: 80px;
        padding: 5px;
        font-size: 16px;
        text-align: center;
        margin-right: 30px;
        box-sizing: border-box;
    }

    .time-container input[type="checkbox"] {
        margin-left: 30px;
    }

    .container {
        margin-bottom: 20px;
        /* Расстояние между контейнерами */
        max-width: 450px;
        margin: 0;
        background-color: #F0F2F5;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        justify-content: space-between;
        align-items: center;
    }

    .radio-label {
        display: inline-flex;
        align-items: center;
        margin-right: 10px;
    }

    .section {
        margin-bottom: 20px;
    }

    button:hover {
        background: linear-gradient(to bottom, #5aafd5, #458dbb);
    }

    /* Стили для состояния нажатия на кнопку */
    button:active {
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        /* Уменьшаем тень при нажатии */
    }

    .tablinks:hover,
    .tablinks.active {
        background: linear-gradient(to bottom, #5aafd5, #458dbb);
    }

    .tab {
        display: none;
        
    }

    .tab.active {
        display: block;
    }

    .hidden {
        display: none;
    }

    .switch {
        position: relative;
        display: inline-block;
        width: 60px;
        height: 34px;
    }

    .switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }

    .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        -webkit-transition: .4s;
        transition: .4s;
    }

    .slider:before {
        position: absolute;
        content: "";
        height: 26px;
        width: 26px;
        left: 4px;
        bottom: 4px;
        background-color: white;
        -webkit-transition: .4s;
        transition: .4s;
    }

    input:checked+.slider {
        background-color: #2196F3;
    }

    input:checked+.slider:before {
        -webkit-transform: translateX(26px);
        -ms-transform: translateX(26px);
        transform: translateX(26px);
    }

    /* Rounded sliders */
    .slider.round {
        border-radius: 34px;
    }

    .slider.round:before {
        border-radius: 50%;
    }
</style>

</head>
<body>

<div id="fileList"></div>

<!-- Модальное окно для добавления реле -->
<div class="modal-overlay" id="addRelayModal" style="display: none;"></div>
<div class="modal" id="addRelayModalWindow" style="display: none;">
    <h2>Добавить реле</h2>
    <form id="addRelayForm">
        <!-- Обрамленный блок с настройками реле -->
        <div style="border: 1px solid #ccc; padding: 10px; margin-bottom: 20px;">
            <h4>Настройки реле</h4>
			<!-- Блок для отображения статуса добавления -->
    		<div id="statusAddRelayMessage" style="padding: 10px; margin-top: 15px; display: none;"></div>
            <!-- Номер пина с выпадающим списком -->
            <label for="pin">Номер пина:</label>
            <select name="pin" id="pin" required>

                <!-- Добавьте другие опции по необходимости -->
            </select><br>

            <!-- Режим пина -->
            <label for="modePin">Режим пина:</label>
            <select name="modePin" id="modePin">
                <option value="INPUT">INPUT</option>
                <option value="OUTPUT">OUTPUT</option>
                <option value="INPUT_PULLUP">INPUT_PULLUP</option>
                <option value="INPUT_PULLDOWN">INPUT_PULLDOWN</option>
            </select><br>

            <!-- Чекбокс с лейблом (Ручной режим) -->
            <div class="checkbox-container">
                <input type="checkbox" name="manualMode" id="manualMode">
                <label for="manualMode">Ручной режим:</label><br>
				
				<br>
            <!-- Чекбокс с лейблом (Состояние пина) -->
           
            <input type="checkbox" name="statePin" id="statePin">
            <label for="statePin">Состояние пина (On/Off):</label><br>
 			</div>
 			
            <!-- Описание -->
            <label for="description">Описание:</label>
            <input type="text" name="description" id="description" value="Реле_1"><br>
        </div>
    </form>

    <!-- Кнопки для сохранения или отмены -->
    <button type="button" onclick="addRelay()">Добавить</button>
    <button type="button" onclick="closeAddRelayForm()">Закрыть</button>
</div>




<!-- Модальное окно для редактирования настроек -->
<div class="modal-overlay" id="settingsModal" style="display: none;"></div>
<div class="modal" id="modalWindow" style="display: none;">
    <h2>Настройки реле</h2>
    <form id="relaySettingsForm">
    
        <div style="border: 1px solid #ccc; padding: 10px; margin-bottom: 20px;">
            
        </div>
    </form>

    <button type="button" onclick="saveRelaySettings()">Применить</button>
    <button type="button" onclick="closeRelaySettings()">Закрыть</button>  
    <button type="button" onclick="showAddRelayForm()">Добавить реле</button>
</div>


<!-- Модальное окно для редактирования настроек  с вкладками -->

<div style="display: flex; align-items: center; justify-content: space-between; position: relative;">
    <h1>Kolibri WiFi Manager</h1>
    <div style="display: flex; align-items: center;">
        <!-- Кнопка для открытия меню настроек с отступом слева -->
        <button onclick="showRelaySettings()" style="margin-left: 10px;">⚙️</button>
        <!-- Кнопка информации с отступом слева -->
        <button onclick="getStatus()" style="margin-left: 5px;">ℹ️</button> 
        
       <button onclick="getHelp('helpContentEsp32')" style="margin-left: 5px;">❓</button>
    </div>
</div>

<!-- Модальное окно для Справки -->
<div class="modal-overlay" id="helpModal" style="display: none;"></div>
<div class="modal" id="helpModalWindow" style="display: none;">
     <h2>Справка</h2>
     <form id="helpForm">
       
    <div id="helpContent"  class="modal-content" style="border: 1px solid #ccc; padding: 20px;">
        <!-- Контент будет подставляться сюда -->
  
    </div>
    </form>
    <button type="button" onclick="closeHelp()">Закрыть</button>
</div>

<!-- Скрытые элементы с контентом справки -->
<div id="helpContentEsp32" style="display: none;">
      <p><strong>ESP32-wroom</strong></p>
            <p><strong>Используемые порты на выход/вход:</strong></p>
            <ul>
                <li>23, 22, 1, 3, 21, 19, 18, 5, 17, 16, 33, 32</li>
            </ul>

            <p><strong>Только входы:</strong></p>
            <ul>
                <li>35, 34, 39, 36</li>
            </ul>

            <p><strong>Зарезервированы:</strong></p>
            <ul>
                <li>PIN 33 - спящий режим при низком уровне</li>
                <li>PIN 32 - датчик температуры</li>
            </ul>

            <p><strong>Конфигурация для спящего режима:</strong></p>
            <pre>
              		 R1 10K
                GND o───[===]─────┐
                                  │
                                  ├──────o PIN 33            
            VIN / 3.3v   R2 10K   │
                    o───[===]─────┘
            </pre>
            <p><strong>VIN</strong> (в случае питания через VIN) или соединить <strong>PIN 3.3v</strong> с <strong>PIN 33</strong></p>
            <p>R1, R2 - делитель напряжения, два одинаковых резистора по 10 кОм</p>

            <hr>

            <p><strong>Конфигурация температурного датчика:</strong></p>
            <pre>
                R3 10K      R4 NTC 10K t˚
     PIN 3.3v o───[===]───┬────[===]──────o GND
                          │
                          │
                          o PIN 32
            </pre>
            <p><strong>Примечания:</strong></p>
            <ul>
                <li>R3, R4: Можно сконфигурировать в программе.</li>
                <li>#define SERIAL_R 10000 // сопротивление последовательного резистора, 10 кОм</li>
                <li>#define THERMISTOR_R 10000 // номинальное сопротивление термистора, 10 кОм</li>
            </ul>
</div>

<div id="helpContentTelegram" style="display: none;">
    <h3>Создание телеграм-бота</h3>

    <p><strong>1. Отправьте в чат с <a href="https://t.me/BotFather" target="_blank">@BotFather</a> команду /newbot</strong></p>
    <p>Введите название бота</p>
    
    <p><strong>2. Введите юзернейм бота</strong> — его техническое имя, которое будет отображаться в адресной строке. 
    Юзернейм должен быть уникальным, написан на латинице и обязательно заканчиваться на <strong>bot</strong>. Готово. </p>

    <p><strong>BotFather</strong> пришлет токен бота — его можно использовать для настройки.</p>

    <p><strong>3. Если нужно отдельно узнать ID токен бота:</strong></p>
    <ul>
        <li>Введите команду /mybots</li>
        <li>Выберите бота (если их больше одного)</li>
        <li>Нажмите <strong>API Token</strong></li>
    </ul>

    <p><strong>4. Узнать ID своего пользователя в Телеграм:</strong></p>
    <p>Найдите чат <a href="https://t.me/getmyid_bot" target="_blank">@getmyid_bot</a> и отправьте команду /start</p>
</div>




<script>
    // Функция для отображения модального окна
    function getHelp(contentId) {
    // Показываем модальное окно
    document.getElementById("helpModal").style.display = "block";
    document.getElementById("helpModalWindow").style.display = "block"; 

    // Получаем элемент для контента
    var helpContent = document.getElementById("helpContent");

    // Считываем содержимое скрытого элемента с нужным id
    var content = document.getElementById(contentId).innerHTML;
    helpContent.innerHTML = content;
}

    // Функция для закрытия модального окна
    function closeHelp() {
        document.getElementById("helpModal").style.display = "none";
        document.getElementById("helpModalWindow").style.display = "none"; // Скрываем окно
    }

    // Закрытие модального окна при клике на затемнение
    window.onclick = function(event) {
        if (event.target == document.getElementById("helpModal")) {
            closeHelp();
        }
    }
</script>


  <div id="status"></div>
  <div id="statusTelegram"></div> 
	<br>
  <div>
    <button class="tablinks" onclick="openTab(event, 'WiFi')" id="defaultOpen">Настройка WiFi</button>
    <button class="tablinks" onclick="openTab(event, 'Telegram')">Настройка Telegram бота</button>
    <button class="tablinks" onclick="openTab(event, 'Control')">Управление</button>
  </div>

  <div id="WiFi" class="tab active">
  	<div class="modal-settings">
    <h2>Настройка подключения WiFi</h2>
    <label>
      <input type="radio" id="client" name="mode" value="client" onchange="toggleMode()"> Клиент
    </label>
    <label>
      <input type="radio" id="is_ap" name="mode" value="is_ap" checked onchange="toggleMode()"> Точка доступа
    </label>
    <div id="clientSettings">
      <label>
        <input type="radio" id="dhcp" name="ip_mode" value="dhcp" checked onchange="toggleIPMode()"> DHCP
      </label>
      <label>
        <input type="radio" id="static" name="ip_mode" value="static" onchange="toggleIPMode()"> Статический IP
      </label>
    </div>
    
    <div id="staticIPSettings" class="hidden">
      <label for="static_ip">IP адрес:</label>
      <input type="text" id="static_ip" name="static_ip"><br>
      <label for="gateway">Шлюз:</label>
      <input type="text" id="gateway" name="gateway"><br>
      <label for="subnet">Маска подсети:</label>
      <input type="text" id="subnet" name="subnet"><br>
      <label for="dns">DNS:</label>
      <input type="text" id="dns" name="dns"><br>
      
    </div>
   <button class="butScan" onclick="scanWiFi()" id="scanButton">Сканировать WiFi сети</button>
   
<div id="networks"></div>
<form id="connectForm" style="display:none;">
    <h2>Подключиться к WiFi</h2>
    <label for="ssid">SSID:</label>
    <input type="text" id="ssid" name="ssid"><br>
    <label for="password">Пароль:</label>
    <input type="text" id="password" name="password"><br>
    <!-- <button type="button" onclick="connectWiFi()">Подключиться</button> -->
</form>

  
  
<div id="apSettings" class="hidden">
    <h2>Настройка точки доступа</h2>
    <form>
        <label for="ap_ssid">SSID точки доступа:</label>
        <input type="text" id="ap_ssid" name="ap_ssid" value="KolibriAP"><br>
        <label for="ap_password">Пароль точки доступа:</label>
        <input type="text" id="ap_password" name="ap_password"><br>
        <label for="ap_ip">IP адрес точки доступа:</label>
        <input type="text" id="ap_ip" name="ap_ip" value="192.168.1.1"><br>
        <!-- <button type="button" onclick="setAccessPoint()">Установить точку доступа</button> -->
    </form>
</div>  

 </div>   <!-- конец <div class="modal-settings"> -->
</div>  <!-- конец  <div id="WiFi" class="tab active"> -->

  <div id="Telegram" class="tab">
   <div class="modal-settings">
    <h2>Настройка Telegram бота</h2>

         <div class="input-group">
        <label for="isTelegramOnCheckbox">Использовать телеграм</label>
        <label class="switch">
            <input type="checkbox" class="switchCheckbox" id="isTelegramOn" checked>
            <span class="slider round"></span>
        </label>
       </div>

<form id="telegramForm" onsubmit="return false">
    <label for="botId">ID телеграм бота:</label>
    <input type="text" id="botId" name="botId" style="width: 455px;">
    
    <button type="button" onclick="setBotId()">Задать</button>
    
    <label for="userId">ID пользователя:</label>
    <input type="text" id="userId" name="userId">
    
    <button type="button" onclick="addUser()">Добавить</button><br><br>

    <div id="userTable" class="hidden">
        <h2>Добавленные пользователи</h2>
        <table>
            <thead>
                <tr>
                    <th>ID пользователя</th>
                    <th>Чтение</th>
                    <th>Управление</th>
                    <th></th>
                </tr>
            </thead>
            <tbody id="userList">
                <!-- Здесь будут отображаться добавленные пользователи -->
            </tbody>
        </table>
    </div>
   
	</form>
<!-- Кнопка "?" для справки -->
    <button onclick="getHelp('helpContentTelegram')" style="position: absolute; top: 5px; right: 5px; ">❓</button>
   </div> 
  </div>


<div id="Control" class="tab">

  <!-- Форма для устройства -->
  <div id="deviceSettingsForm">
  
  <div class="modal-settings">
  <h2>Управление</h2>
    <!-- control.html -->
    <div id="relayContainer">
      <!-- Список реле будет генерироваться здесь -->
    </div>

    <div class="relay-temperature">Температура: <span id="temperature">0°C</span></div>
    
   <div class="relay-currentDateTime">
    Дата и время: <span id="currentDateTime"></span>
    <button id="setDateTimeButton">Настройка</button>
</div>

<!-- Скрытый блок для ввода данных -->
<div id="dateTimeSettings" style="display: none; margin-top: 10px;">
    <input type="date" id="dateInput" />
    <input type="time" id="timeInput" />
    <button id="applyDateTimeButton" onclick="setDateTime()">Установить</button>
</div>


    <br>

    <button type="button" id="resetManual" onclick="resetAllRelaysToAuto()">Сбросить все в Auto</button>

 </div>

    <div class="modal-settings">
      <h2>Настройки устройства</h2>
      <!-- Вторая форма для настроек -->
      <form id="formScenario">
        
        <div class="input-group">
          <label for="useSetting">Использовать настройку</label>
          <label class="switch">
            <input type="checkbox" class="switchCheckbox" id="useSetting" name="useSetting" >
            <span class="slider round"></span>
          </label>
        </div>
        

        <!-- Числовое поле для температуры -->
        <div class="input-group-temperature">
          <label for="temperature">Температура</label>
          <input type="number" id="setTemperature" name="setTemperature" min="-50" max="50" value="22">
          <input type="checkbox" class="switchCheckbox" id="temperatureCheckbox" name="temperatureCheckbox" >
          <label for="temperatureCheckbox">Включить</label>
        </div>

        <!-- Поля для даты и времени включения/выключения -->
        <div class="time-container">
          <label for="startDate">Дата и время включения</label>
          <input type="date" id="startDate" name="startDate" >
          <input type="time" id="startTime" name="startTime" value="00:00">
        </div>
        <div class="time-container">
          <label for="endDate">Дата и время выключения</label>
          <input type="date" id="endDate" name="endDate">
          <input type="time" id="endTime" name="endTime" value="00:00">
        </div>
        
 <!-- Множественный выбор дней недели -->
        <div class="custom-select">
            <div class="selected-values" onclick="toggleDropdown()">Выберите дни недели</div>
            <div class="options" id="weekdays-dropdown">
                <label for="monday">
                    <input type="checkbox" id="monday" name="monday" value="Понедельник" checked> Понедельник
                </label>
                <label for="tuesday">
                    <input type="checkbox" id="tuesday" name="tuesday" value="Вторник" checked> Вторник
                </label>
                <label for="wednesday">
                    <input type="checkbox" id="wednesday" name="wednesday" value="Среда" checked> Среда
                </label>
                <label for="thursday">
                    <input type="checkbox" id="thursday" name="thursday" value="Четверг" checked> Четверг
                </label>
                <label for="friday">
                    <input type="checkbox" id="friday" name="friday" value="Пятница" checked> Пятница
                </label>
                <label for="saturday">
                    <input type="checkbox" id="saturday" name="saturday" value="Суббота" checked> Суббота
                </label>
                <label for="sunday">
                    <input type="checkbox" id="sunday" name="sunday" value="Воскресенье" checked> Воскресенье
                </label>
            </div>
        </div>
        
        
        <!-- Контейнер с настройками -->
  <div class="settings-container" id="settingsContainer" style="display: none;">

        <!-- Поля выбора пинов -->
        <div class="input-group-pin" style="margin-top: 20px;">
          <label for="pinRelays">Номер пина реле:</label>
          <select name="pinRelays" id="pinRelays" required>
            <option value="" disabled selected>Выберите пин</option>
          </select>
        </div>
        
        <!-- Поля выбора пинов -->
        <div class="input-group-pin" style="margin-top: 20px;">
          <label for="pinRelays2">Номер пина реле 2:</label>
          <select name="pinRelays2" id="pinRelays2" required>
            <option value="" disabled selected>Выберите пин</option>
          </select>
        </div>
        
         <div class="input-group-temperature">
         <label for="timeInterval">Интервал в сек.</label>
          <input type="number" id="timeInterval" name="timeInterval" min="1" max="86400" value="1800">
          </div>
          
    </div>
    
		<br>
        <!-- Кнопка отправки данных -->
        <button type="button" onclick="saveDataScenario(event)">Применить</button>
      </form> <!-- Закрытие формы formScenario -->
      
         <!-- Кнопка с шестеренкой для показа/скрытия настроек -->
  <button type="button" id="toggleSettingsBtn" class="settings-toggle-btn">
    ⚙️ <!-- Иконка шестеренки как символ -->
  </button>
      
    </div>

  </div> <!-- Закрытие формы deviceSettingsForm -->
</div> <!-- Закрытие div Control -->

<!-- JavaScript для переключения видимости -->
<script>
  // Получаем элементы кнопки и контейнера
  const toggleBtn = document.getElementById('toggleSettingsBtn');
  const settingsContainer = document.getElementById('settingsContainer');

  // Добавляем обработчик для кнопки
  toggleBtn.addEventListener('click', function() {
    // Переключаем видимость контейнера
    if (settingsContainer.style.display === 'none' || settingsContainer.style.display === '') {
      settingsContainer.style.display = 'block';
    } else {
      settingsContainer.style.display = 'none';
    }
  });
</script>



  <!-- 
   Элемент для отображения статуса -->

	<br>

    <button class="butScan" onclick="applySettings()" id="applySettings" style="font-weight: 600; white-space: nowrap;">Сохранить настройки</button>
    <button class="butScan" onclick="restartDevice()">Перезагрузить</button>
   
    
  <h3 id="fileStatus">Обновить прошивку</h3>
  
<div style="margin-bottom: 20px;">
    <button id="uploadButton">Открыть файл</button>
    <button id="downloadButton">Скачать прошивку</button>
  </div>
 
  <div id="downloadLink">
    <a href="https://cloud.mail.ru/public/KtJ5/WgxbfXTrP" target="_blank">Скачать прошивку</a>
  </div>
  <div id="copyMessage">Ссылка скопирована. Подключитесь к интернету и скачайте файлы.</div>

  <input type="file" id="fileInput" style="display:none" onchange="uploadFile()">

    
    <div id="statusControl"></div> 
</form>
	
    <script>
    
   let availablePins;
   let ocupationPins = [];
   

    // Обработчик для кнопки "Настройка"
    document.getElementById('setDateTimeButton').addEventListener('click', function () {
        const settingsDiv = document.getElementById('dateTimeSettings');
        const dateInput = document.getElementById('dateInput');
        const timeInput = document.getElementById('timeInput');

        // Переключение видимости блока настроек
        if (settingsDiv.style.display === 'none') {
            const now = new Date();
            dateInput.value = now.toISOString().slice(0, 10); // Формат YYYY-MM-DD
            timeInput.value = now.toTimeString().slice(0, 5); // Формат HH:MM

            settingsDiv.style.display = 'block';
        } else {
            settingsDiv.style.display = 'none';
        }
    });

    // Обработчик для кнопки "Установить"

function setDateTime() {
console.log('setDateTime');

	const dateInput = document.getElementById('dateInput').value;
    const timeInput = document.getElementById('timeInput').value;
	
    // Создаем объект FormData
     let data = new FormData();
    data.append('date', dateInput);
    data.append('time', timeInput);

    fetch('/setDateTime', {
        method: 'POST',
        body: data
    })
    .then(response => response.text())
    .then(text => {
         // Обновляем состояние после отправки команды
    })
    .catch(error => console.error('Error:', error));
}

   
   //=================================
   
   function setCurrentDateForInputDate() {
    // Получаем текущую дату и время
    const currentDate = new Date();

    // Форматируем текущую дату в формате YYYY-MM-DD для поля типа date
    const dateStr = currentDate.toISOString().split('T')[0];  // "YYYY-MM-DD"
    
    // Форматируем текущее время в формате HH:MM для поля типа time
    const timeStr = currentDate.toTimeString().split(' ')[0].slice(0, 5);  // "HH:MM"
    
    // Заполняем поля формы значениями текущей даты и времени
    document.getElementById('dateInput').value = dateStr;
    document.getElementById('timeInput').value = timeStr;
    
	}
   
   
   function setCurrentDate() {
    // Получаем текущую дату и время
    const currentDate = new Date();

    // Форматируем текущую дату в формате YYYY-MM-DD для поля типа date
    const dateStr = currentDate.toISOString().split('T')[0];  // "YYYY-MM-DD"
    
    // Форматируем текущее время в формате HH:MM для поля типа time
    const timeStr = currentDate.toTimeString().split(' ')[0].slice(0, 5);  // "HH:MM"
    
    // Заполняем поля формы значениями текущей даты и времени
    document.getElementById('startDate').value = dateStr;
    document.getElementById('startTime').value = timeStr;
    document.getElementById('endDate').value = dateStr;
    document.getElementById('endTime').value = timeStr;
    
    //document.getElementById('dateInput').value = dateStr;
    //document.getElementById('timeInput').value = timeStr;
    
	}
    
    
    function populatePinSelect(selectId) {
    // Получаем элемент select по переданному ID
    const pinSelect = document.getElementById(selectId);

    // Проверяем, что элемент существует
    if (!pinSelect) {
        console.error(`Элемент с ID ${selectId} не найден`);
        return;
    }

    // Очищаем текущие опции
    pinSelect.innerHTML = '';

    // Добавляем опции пинов из глобальной переменной availablePins
    availablePins.forEach(pin => {
        const option = document.createElement('option');
        option.value = pin;
        option.textContent = `Pin ${pin}`; // Текст, который будет отображаться в выпадающем списке

        // Проверяем, если пин занят (он есть в массиве ocupationPins)
       //  if (ocupationPins.includes(pin)) {
//             // Добавляем класс для окрашивания занятых пинов
//             option.classList.add('option-disabled');  // Применяем стиль через класс
//             option.disabled = true;  // Отключаем выбор этого пина
//         }
// Проверяем, если пин занят (он есть в массиве ocupationPins)
        if (ocupationPins.includes(pin)) {
            option.textContent = `Pin ${pin} занят`; // Добавляем надпись "Занят"
            option.classList.add('option-disabled');  // Применяем стиль через класс
        } else {
            option.textContent = `Pin ${pin}`; // Для свободных пинов просто выводим номер пина
        }


        pinSelect.appendChild(option);
    });
}

//==========

 function setCurrenDate() {
 	const currentDate = new Date();

    // Получаем строку времени в формате HH:MM
    const formattedTime = currentDate.getHours().toString().padStart(2, '0') + ":" + currentDate.getMinutes().toString().padStart(2, '0');
    
    // Получаем строку даты в формате YYYY-MM-DD
    const formattedDate = currentDate.toISOString().split('T')[0]; // Преобразуем в формат YYYY-MM-DD

    // Устанавливаем текущую дату и время в форму
    document.getElementById('startDate').value = formattedDate;
    document.getElementById('startTime').value = formattedTime;
    document.getElementById('endDate').value = formattedDate;
    document.getElementById('endTime').value = formattedTime;
 }

// Функция для получения настроек с сервера и заполнения формы
        function getFormScenario() {
    console.log('getFormScenario');
    
    fetch('/getFormScenario')
        .then(response => response.json())  // Преобразуем ответ в формат JSON
        .then(data => {
            console.log('getFormScenario Received data:', data);
            
            // Заполняем форму данными
            document.getElementById('useSetting').checked = data.useSetting;
            document.getElementById('setTemperature').value = data.setTemperature; 
            document.getElementById('temperatureCheckbox').checked = data.temperatureCheckbox;
            document.getElementById('startDate').value = data.startDate;
            document.getElementById('startTime').value = data.startTime;
            document.getElementById('endDate').value = data.endDate;
            document.getElementById('endTime').value = data.endTime;
            document.getElementById('pinRelays').value = data.pinRelays;
            document.getElementById('pinRelays2').value = data.pinRelays2;
            
            document.getElementById('timeInterval').value = data.timeInterval; 
            
            // Заполняем чекбоксы для дней недели
            const week = data.week;  // week уже является массивом (не нужно парсить)
            document.getElementById('monday').checked = week[0];
            document.getElementById('tuesday').checked = week[1];
            document.getElementById('wednesday').checked = week[2];
            document.getElementById('thursday').checked = week[3];
            document.getElementById('friday').checked = week[4];
            document.getElementById('saturday').checked = week[5];
            document.getElementById('sunday').checked = week[6];
        })
        .catch(error => {
            console.error('Error:', error);
            
            setCurrentDate();  // Выводим текущую дату при ошибке
        });
}

function saveDataScenario(event) {
    event.preventDefault();

    const form = document.getElementById('formScenario');
    if (!(form instanceof HTMLFormElement)) {
        console.error('Элемент не является формой!');
        return;
    }

    const formData = new FormData(form);

    // Собираем значения для дней недели
    const week = {
        monday: document.getElementById('monday').checked,
        tuesday: document.getElementById('tuesday').checked,
        wednesday: document.getElementById('wednesday').checked,
        thursday: document.getElementById('thursday').checked,
        friday: document.getElementById('friday').checked,
        saturday: document.getElementById('saturday').checked,
        sunday: document.getElementById('sunday').checked,
    };

    // Добавляем объект week в formData (удаляем дублирование)
    formData.delete('week'); // Удаляем, если уже существует
    formData.set('week', JSON.stringify(week));

    // Обрабатываем чекбоксы, избегая дублирования
    const checkboxes = form.querySelectorAll('input[type="checkbox"]');
    checkboxes.forEach(checkbox => {
        formData.delete(checkbox.name); // Удаляем, если уже существует
        formData.set(checkbox.name, checkbox.checked ? 'true' : 'false');
    });

    // Обработка select
    const select = document.getElementById('pinRelays');
    const select2 = document.getElementById('pinRelays2');

    if (select.value) {
        formData.delete('pinRelays'); // Удаляем, если уже существует
        formData.set('pinRelays', select.value);
    }
    
    console.log('select2.value', select2.value);

    if (select2.value) {
        formData.delete('pinRelays2'); // Удаляем, если уже существует
        formData.set('pinRelays2', select2.value);
    }

    // Логируем результат для проверки
    for (const [key, value] of formData.entries()) {
        console.log(`${key}: ${value}`);
    }

    fetch('/formScenario', {
        method: 'POST',
        body: formData,
    })
        .then(response => response.json())
        .then(data => {
            console.log('Данные успешно отправлены на сервер:', data);
        })
        .catch(error => {
            console.error('Ошибка при отправке данных:', error);
        });
}

    
    // Функция для показа окна добавления реле
function showAddRelayForm() {
    closeRelaySettings();

    // Открыть модальное окно для добавления реле
    document.getElementById('addRelayModal').style.display = 'block';
    document.getElementById('addRelayModalWindow').style.display = 'block';

    // Получаем элемент select для пинов
    const pinSelect = document.getElementById('pin');

    
    populatePinSelect('pin');
}


// Функция для закрытия окна добавления реле
function closeAddRelayForm() {
    document.getElementById('addRelayModal').style.display = 'none';
    document.getElementById('addRelayModalWindow').style.display = 'none';
    
    showRelaySettings();
}

// Функция для сохранения нового реле
function addRelay() {
    const formElement = document.getElementById('addRelayForm');
    const formData = new FormData(formElement);

    // Проверка, если форма корректно заполнена
    if (!formData.get('pin') || !formData.get('modePin')) {
        showStatus('Пожалуйста, заполните все обязательные поля!', 'error');
        return;
    }

    // Автоматически добавляем значения для чекбоксов, если они не установлены
    const checkboxes = formElement.querySelectorAll('input[type="checkbox"]');
    checkboxes.forEach(checkbox => {
        if (!formData.has(checkbox.name)) { // Если чекбокс не был выбран
            formData.append(checkbox.name, 'false'); // Добавляем значение "false"
        }
    });

    // Отправка данных на сервер
    fetch('/addRelay', {
        method: 'POST',
        body: formData // Передаем FormData напрямую
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`Ошибка: ${response.statusText}`);
        }
        return response.json(); // Парсим ответ в формате JSON
    })
    .then(data => {
        if (data.status === "Success") {
            showStatus('Реле успешно добавлено!', 'success');
            // Очистить поля формы после успешного добавления
            formElement.reset();
        } else {
            showStatus(`Ошибка: ${data.message}`, 'error');
        }
    })
    .catch(error => {
        showStatus('Ошибка при добавлении реле', 'error');
        console.error('Error:', error);
    });
}

// Функция для отображения сообщения о статусе
function showStatus(message, type) {
    const statusMessage = document.getElementById('statusAddRelayMessage');
    statusMessage.textContent = message;
    statusMessage.style.display = 'block';
    
    if (type === 'success') {
        statusMessage.style.backgroundColor = '#d4edda'; // Зеленый цвет для успеха
        statusMessage.style.color = '#155724';
        statusMessage.style.border = '1px solid #c3e6cb';
    } else if (type === 'error') {
        statusMessage.style.backgroundColor = '#f8d7da'; // Красный цвет для ошибки
        statusMessage.style.color = '#721c24';
        statusMessage.style.border = '1px solid #f5c6cb';
    }
}



    
  // Функция для показа окна настроек реле
function showRelaySettings() {
    console.log('showRelaySettings');
    document.getElementById('settingsModal').style.display = 'block';
    document.getElementById('modalWindow').style.display = 'block';
    
    loadRelaySettings();
}

// Функция для закрытия окна настроек реле
function closeRelaySettings() {
    document.getElementById('settingsModal').style.display = 'none';
    document.getElementById('modalWindow').style.display = 'none';
}

function loadPins() {
    fetch('/getRelaySettings')
        .then(response => {
            if (!response.ok) {
                throw new Error('Failed to fetch relay settings');
            }
            return response.json();
        })
        .then(data => {
            console.log('getRelaySettings', data);

            // Заполнение переменной availablePins с доступными пинами
            availablePins = data.availablePins || [];  // Доступные пины из ответа сервера (предполагаем, что сервер передает такой массив)

            // Фильтруем пины, которым назначен режим (mode)
            ocupationPins = data.relays
                .filter(relay => relay.modePin)  // Отбираем реле, у которых есть режим
                .map(relay => relay.pin);        // Извлекаем пины с назначенным режимом

            console.log('Available Pins:', availablePins);
            console.log('Occupied Pins:', ocupationPins);

            // Вызов функции для заполнения select с доступными пинами
            populatePinSelect('pinRelays'); // Замените 'pinRelays' на нужный ID вашего элемента select
             populatePinSelect('pinRelays2');
        })
        .catch(error => {
            console.error('Ошибка при загрузке настроек реле:', error);
        });
}

function loadRelaySettings() {
    fetch('/getRelaySettings')
        .then(response => {
            if (!response.ok) {
                throw new Error('Failed to fetch relay settings');
            }
            return response.json();
        })
        .then(data => {
            console.log('getRelaySettings', data);
            // availablePins =  data.availablePins;
             // Фильтруем пины, которым назначен режим (mode)
            ocupationPins = data.relays
                .filter(relay => relay.modePin)  // Отбираем реле, у которых есть режим
                .map(relay => relay.pin);        // Извлекаем пины с назначенным режимом

            console.log('Ocupation Pins:', ocupationPins);

            const relaySettingsForm = document.getElementById('relaySettingsForm');
            relaySettingsForm.innerHTML = ''; // Очистить форму перед загрузкой новых данных

            data.relays.forEach((relay, index) => {
            
                const relayContainer = document.createElement('div');

				// Задаем стиль непосредственно для рамки через атрибут style
    relayContainer.style.border = '1px solid #999';  // Темная рамка
    relayContainer.style.padding = '20px';            // Отступы внутри контейнера
    relayContainer.style.marginBottom = '20px';       // Отступ снизу
    relayContainer.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.1)';  // Тень для контейнера
    relayContainer.style.borderRadius = '10px'; 

                relayContainer.setAttribute('data-index', index);

                const heading = document.createElement('h4');
                heading.textContent = 'Реле ' + (index + 1);
                relayContainer.appendChild(heading);
            
                // Поле для названия реле
                relayContainer.appendChild(createLabelInput('description', 'description-' + index, 'Название:', 'text', relay.description));

                relaySettingsForm.appendChild(relayContainer);

                // Создаем строку для select-элементов
                const selectRow = document.createElement('div');
                selectRow.classList.add('select-row');

                const availablePinsForRelay = data.availablePins;
                 availablePins =  data.availablePins;
                
                selectRow.appendChild(createLabelSelect(
                    'pin',
                    'pin-' + index,
                    'Пин:',
                    relay.pin,
                    availablePinsForRelay.map(pin => ({ value: pin, label: pin.toString() }))
                ));

                selectRow.appendChild(createLabelSelect(
                    'modePin',
                    'modePin-' + index,
                    'Режим пина:',
                    relay.modePin,
                    [
                        { value: 'INPUT', label: 'INPUT' },
                        { value: 'OUTPUT', label: 'OUTPUT' },
                        { value: 'INPUT_PULLUP', label: 'INPUT_PULLUP' },
                        { value: 'INPUT_PULLDOWN', label: 'INPUT_PULLDOWN' }
                    ]
                ));

                relayContainer.appendChild(selectRow);

                // Создаем группу чекбоксов
                const checkboxGroup = document.createElement('div');
                checkboxGroup.classList.add('checkbox-group');

                checkboxGroup.appendChild(createLabelCheckbox('manualMode', 'manualMode-' + index, 'Ручной режим:', relay.manualMode));
                checkboxGroup.appendChild(createLabelCheckbox('statePin', 'statePin-' + index, 'Состояние пина:', relay.statePin));

                relayContainer.appendChild(checkboxGroup);

                // Добавляем кнопку "Удалить"
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Удалить';
                deleteButton.classList.add('modal-button'); // Применяем основной стиль , 'delete-button
                deleteButton.addEventListener('click', () => {
                    relayContainer.remove(); // Удаляет контейнер реле
                });

                relayContainer.appendChild(deleteButton);
            });
        });
}

// Закрытие функции loadRelaySettings


function createLabelInput(name, id, labelText, type, value) {
    const container = document.createElement('div');

    const label = document.createElement('label');
    label.setAttribute('for', id);
    label.textContent = labelText;
    container.appendChild(label);

    const input = document.createElement('input');
    input.type = type;
    input.name = name;
    input.id = id;
    input.value = value || '';
    container.appendChild(input);

    return container;
}

function createLabelSelect(name, id, labelText, selectedValue, options) {
    const container = document.createElement('div');

    const label = document.createElement('label');
    label.setAttribute('for', id);
    label.textContent = labelText;
    container.appendChild(label);

    const select = document.createElement('select');
    select.name = name;
    select.id = id;

    options.forEach(option => {
        const opt = document.createElement('option');
        opt.value = option.value;
        opt.textContent = option.label;
        if (option.value === selectedValue) {
            opt.selected = true;
        }
        select.appendChild(opt);
    });

    container.appendChild(select);
    return container;
}

function createLabelCheckbox(name, id, labelText, checked) {
    const container = document.createElement('div');
    
    // Добавляем класс для выравнивания чекбокса с лейблом
    container.classList.add('checkbox-container');
    
    const label = document.createElement('label');
    label.setAttribute('for', id);
    label.textContent = labelText;
    container.appendChild(label);

    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.name = name;
    checkbox.id = id;
    checkbox.checked = checked || false;
    container.appendChild(checkbox);

    return container;
}


//=============

function saveRelaySettings() {
    console.log('saveRelaySettings');
    const relaySettingsForm = document.getElementById('relaySettingsForm');
    const relaySettings = []; // Создаем массив для хранения настроек реле

    // Проходим по всем дочерним элементам формы
    Array.from(relaySettingsForm.children).forEach(relayContainer => {
        const index = relayContainer.getAttribute('data-index');

        // Получаем значения из полей ввода и добавляем их в массив
        const relaySetting = {
            pin: parseInt(document.getElementById('pin-' + index).value),
            modePin: document.getElementById('modePin-' + index).value,
            manualMode: document.getElementById('manualMode-' + index).checked,
            statePin: document.getElementById('statePin-' + index).checked,
            description: document.getElementById('description-' + index).value,
        };

        relaySettings.push(relaySetting); // Добавляем объект в массив

        console.log('Added relay:', relaySetting);
    });

    // Отправка данных на сервер
    let formData = new FormData();
    formData.append('relaySettings', JSON.stringify(relaySettings));
    
    console.log('Added JSON:', JSON.stringify(relaySettings));

    fetch('/saveRelaySettings', {
        method: 'POST',
        body: formData
    })
        .then(response => {
            if (!response.ok) {
                throw new Error('Failed to update relay settings');
                alert('Ошибка сохранения');
            }
            return response.json(); // Обработка ответа
        })
        .then(data => {
            closeRelaySettings();
            
            console.log('Response from server:', data);
            console.log('Relay settings updated successfully');
        })
        .catch(error => {
            console.error('Error updating relay settings:', error);
            alert('Ошибка сохранения');
        });
}


function resetAllRelaysToAuto() {
    fetch('/resetManual', {
        method: 'POST'
    })
    .then(response => response.text())
    .then(text => {
        console.log(text);
        updateStates(); // Обновляем состояние после сброса
    })
    .catch(error => console.error('Error:', error));
}

function sendCommand(relay, action) {
	console.log('relay', relay);
		console.log('action', action);
    // Создаем объект FormData
    let formData = new FormData();
    formData.append('relay', relay);
    formData.append('action', action);

    fetch('/relay', {
        method: 'POST',
        body: formData
    })
    .then(response => response.text())
    .then(text => {
        console.log(text);
        updateStates(); // Обновляем состояние после отправки команды
    })
    .catch(error => console.error('Error:', error));
}

// Функция для получения состояния реле и обновления UI
function updateStates() {
    fetch('/relayStates')
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
    
        .then(data => {
            console.log(data);

            const container = document.getElementById('relayContainer');
            if (container) {
                container.innerHTML = ''; // Очищаем контейнер перед обновлением

                // Генерируем список реле
                data.relays.forEach(item => {
                    const row = document.createElement('div');
                    row.classList.add('relay-row');
                    row.dataset.relay = item.description;

                    row.innerHTML = `
                        <div class="relay-description">${item.description}</div>
                        <div class="relay-controls">
                            <button type="button" class="relay-on">On</button>
                            <button type="button" class="relay-off">Off</button>
                        </div>
                        <div class="relay-state"> Текущее состояние: 
                            <span style="color: ${item.state ? 'green' : 'red'};">
                                ${item.state ? 'On' : 'Off'}
                            </span>
                        </div>
                        <div class="relay-mode">Режим: ${item.mode}</div>
                    `;

                    // Добавляем обработчики событий для кнопок
                    row.querySelector('.relay-on').addEventListener('click', () => {
                        sendCommand(item.description, 'on');
                    });
                    row.querySelector('.relay-off').addEventListener('click', () => {
                        sendCommand(item.description, 'off');
                    });

                    container.appendChild(row);
                });
            }

            // Обновление температуры
            const tempElement = document.getElementById('temperature');
            if (tempElement) {
                tempElement.textContent = `${data.temp}°C`;
            }

            // Обновление времени
            const timeElement = document.getElementById('currentDateTime');
            if (timeElement) {
                timeElement.textContent = `${data.currentDateTime}`;
            }
        })
        .catch(error => console.error('Error fetching relay states:', error));
}

function sendCommand(relay, action) {
    let formData = new FormData();
    formData.append('relay', relay);
    formData.append('action', action);
    
    fetch('/relay', {
        method: 'POST',
        body: formData
    })
    .then(response => response.text())
    .then(text => {
        console.log(text);
        updateStates(); // Обновляем состояние после отправки команды
    })
    .catch(error => console.error('Error:', error));
}

    //===========Рестрат============//
    function restartDevice() {
    fetch('/restart', {
        method: 'POST'
    })
    .then(response => response.json())
    .then(data => {
        var statusDiv = document.getElementById("statusTelegram");
        var countdown = 10;

        statusDiv.innerHTML = `Устройство перезагружается... Подключение к серверу через ${countdown} секунд.`;
        
        var interval = setInterval(() => {
            countdown--;
            if (countdown > 0) {
                statusDiv.innerHTML = `Устройство перезагружается... Подключение к серверу через ${countdown} секунд.`;
            } else {
                clearInterval(interval);
                statusDiv.innerHTML = "OK"; //"Подключение к серверу...";

                //checkSettingsTelegramApplied();
            }
        }, 1000);
    })
    .catch(error => {
        console.error("Error restarting device:", error);
    });
}

function showCustomAlert(message) {
    const modal = document.createElement('div');
    modal.style.position = 'fixed';
    modal.style.top = '50%';
    modal.style.left = '50%';
    modal.style.transform = 'translate(-50%, -50%)';
    modal.style.backgroundColor = 'white';
    modal.style.border = '1px solid black';
    modal.style.padding = '20px';
    modal.style.zIndex = '1000';
    modal.style.boxShadow = '0px 4px 6px rgba(0,0,0,0.1)';

    const text = document.createElement('p');
    text.textContent = message;
    text.style.margin = '0 0 20px 0';
    text.style.fontSize = '16px';
    modal.appendChild(text);

    const closeButton = document.createElement('button');
    closeButton.textContent = 'ОК';
    closeButton.style.padding = '10px 20px';
    closeButton.style.backgroundColor = '#007BFF';
    closeButton.style.color = 'white';
    closeButton.style.border = 'none';
    closeButton.style.borderRadius = '4px';
    closeButton.style.cursor = 'pointer';
    closeButton.onclick = () => document.body.removeChild(modal);
    modal.appendChild(closeButton);

    document.body.appendChild(modal);
}


function format() {
    // Показать предупреждающий диалог
     fetch('/format', {
            method: 'POST'
        })
        .then(response => response.json())
        .then(data => {
            var statusDiv = document.getElementById("statusTelegram");
            var countdown = 5;

            statusDiv.innerHTML = `Устройство форматируется... Подключение к серверу через ${countdown} секунд.`;
            
             showCustomAlert('Все настройки будут сброшены, дождитесь завершения. Доступ в режиме точки доступа по адресу http://192.168.1.1');
             
            var interval = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    statusDiv.innerHTML = `Устройство форматируется... Подключение к серверу через ${countdown} секунд.`;
                } else {
                    clearInterval(interval);
                    statusDiv.innerHTML = "OK";

                }
            }, 1000);
        })
        .catch(error => {
            console.error("Ошибка перезагрузки устройства:", error);
        });
    
}

    //==========WIFI================//
    
   let tabNameGlobal;
    
 function openTab(evt, tabName) {
  var i, tabcontent, tablinks;
  tabcontent = document.getElementsByClassName("tab");
  for (i = 0; i < tabcontent.length; i++) {
    tabcontent[i].style.display = "none";
  }
  tablinks = document.getElementsByClassName("tablinks");
  for (i = 0; i < tablinks.length; i++) {
    tablinks[i].className = tablinks[i].className.replace(" active", "");
  }
  document.getElementById(tabName).style.display = "block";
  evt.currentTarget.className += " active";

  // Скрыть настройки точки доступа при переключении вкладок
  tabNameGlobal = tabName;
  if (tabName !== 'WiFi') {
    document.getElementById('apSettings').classList.add('hidden');
  }
}
        document.getElementById("defaultOpen").click();
        
 let savedSettings = {}; // Переменная для хранения полученных настроек
 
//=================================================================

function toggleDropdown() {
    const dropdown = document.querySelector('.options');
    dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';
}

// Закрыть выпадающий список, если кликнули за его пределами
document.addEventListener('click', function (event) {
    const dropdown = document.querySelector('.options');
    const customSelect = document.querySelector('.custom-select');
    if (!customSelect.contains(event.target)) {
        dropdown.style.display = 'none';
    }
});


 document.addEventListener("DOMContentLoaded", function() {
    
  loadPins();
  
  getFormScenario();
  
  setCurrentDateForInputDate();
  
 //=============================

    function fetchSettings() {
        fetch('/getsettings')
            .then(response => response.json())
            .then(data => {
            //======Сеть=====//
                savedSettings = data; // Сохраняем полученные данные в переменной
                updateUI(savedSettings); // Обновляем интерфейс с полученными данными
                console.log('data', savedSettings);
            //======Телеграм=====//
            console.log("get_telegram_settings", data.telegramSettings.isTelegramOn);

        // Обновляем поля на странице с полученными данными
        document.getElementById("botId").value = data.telegramSettings.botId;
        document.getElementById("isTelegramOn").checked = data.telegramSettings.isTelegramOn || false;
        var userList = document.getElementById("userList");
        userList.innerHTML = ""; // Очищаем текущий список пользователей

		console.log('telegramUsers',data.telegramSettings.telegramUsers);
		
        data.telegramSettings.telegramUsers.forEach(user => {
            var newRow = document.createElement("tr");
            newRow.innerHTML = `
                <td>${user.id}</td>
                <td><input type="checkbox" name="read" ${user.reading ? "checked" : ""}></td>
                <td><input type="checkbox" name="control" ${user.writing ? "checked" : ""}></td>
                <td><button onclick="deleteUser('${user.id}')">Удалить</button></td>
            `;
            userList.appendChild(newRow);
        });

        if (data.telegramSettings.telegramUsers.length > 0) {
            document.getElementById("userTable").classList.remove("hidden");
        } else {
            document.getElementById("userTable").classList.add("hidden");
        }
    
            //=====================    
                
            })
            .catch(error => console.error('Ошибка при загрузке настроек:', error));
    }

	window.fetchSettings = fetchSettings;

    // Функция для обновления интерфейса с полученными настройками
    function updateUI(data) {
        document.getElementById('ap_ssid').value = data.ssidAP || '';
        document.getElementById('ap_password').value = data.passwordAP || '';
        document.getElementById('ap_ip').value = data.ipAddressAP || '';
        document.getElementById('is_ap').checked = data.isAP || false;

        let currentNetworkSetting = data.networkSettings[data.currentIdNetworkSetting];

        if (currentNetworkSetting) {
            document.getElementById('ssid').value = currentNetworkSetting.ssid || '';
            document.getElementById('password').value = currentNetworkSetting.password || '';
            document.getElementById('static_ip').value = currentNetworkSetting.staticIP || '';
            document.getElementById('gateway').value = currentNetworkSetting.staticGateway || '';
            document.getElementById('subnet').value = currentNetworkSetting.staticSubnet || '';
            document.getElementById('dns').value = currentNetworkSetting.staticDNS || '';

            if (currentNetworkSetting.useStaticIP) {
                document.getElementById('dhcp').checked = false;
                document.getElementById('static').checked = true;
            } else {
                document.getElementById('dhcp').checked = true;
                document.getElementById('static').checked = false;
            }

            console.log('currentNetworkSetting', currentNetworkSetting.staticIP);
        }

        let currentMode = data.isAP ? 'is_ap' : 'client';
        document.getElementById('currentMode').value = currentMode;

        if (data.isAP) {
            document.getElementById('clientSettings').classList.add('hidden');
            document.getElementById('apSettings').classList.remove('hidden');
            document.getElementById('scanButton').classList.add('hidden');
            document.getElementById('networks').classList.add('hidden');
            document.getElementById('staticIPSettings').classList.add('hidden');
            document.getElementById('connectForm').classList.add('hidden');

            // Устанавливаем атрибут checked для радио-кнопки is_ap
            document.getElementById('is_ap').checked = true;
        } else {
            document.getElementById('clientSettings').classList.remove('hidden');
            document.getElementById('apSettings').classList.add('hidden');
            document.getElementById('scanButton').classList.remove('hidden');
            document.getElementById('networks').classList.remove('hidden');
            document.getElementById('connectForm').classList.remove('hidden');
            // Устанавливаем атрибут checked для радио-кнопки client
            document.getElementById('client').checked = true;
        }

        if (data.connected) {
            document.getElementById('status').innerHTML = `<h2>Статус: Подключено к сети: "${currentNetworkSetting.ssid}"</h2>`;
        } else if (data.isAP) {
            document.getElementById('status').innerHTML = `<h2>Статус: Запущена точка доступа: "${data.ssidAP}"</h2>`;
        } else {
            document.getElementById('status').innerHTML = `<h2>Статус: Не подключено</h2>`;
        }

        // Вызов displayNetworks для сохраненных сетей
        displayNetworks(data.networkSettings, true);
    }

		window.updateUI = updateUI;

    // Функция для выбора сети
    function selectNetworkServer(index) {
        if (index >= 0 && index < savedSettings.networkSettings.length) {
            savedSettings.currentIdNetworkSetting = index;
            let selectedNetwork = savedSettings.networkSettings[index];
            document.getElementById('ssid').value = selectedNetwork.ssid || '';
            document.getElementById('password').value = selectedNetwork.password || '';
            document.getElementById('static_ip').value = selectedNetwork.staticIP || '';
            document.getElementById('gateway').value = selectedNetwork.staticGateway || '';
            document.getElementById('subnet').value = selectedNetwork.staticSubnet || '';
            document.getElementById('dns').value = selectedNetwork.staticDNS || '';

            console.log('selectNetworkServer', selectedNetwork);

            if (selectedNetwork.useStaticIP) {
                document.getElementById('dhcp').checked = false;
                document.getElementById('static').checked = true;
            } else {
                document.getElementById('dhcp').checked = true;
                document.getElementById('static').checked = false;
            }
            
            toggleIPMode();
        }
    }

    // Пример использования функции selectNetworkServer
    window.selectNetworkServer = selectNetworkServer;

function displayNetworks(data, saved = false) {
	console.log('displayNetworks',data);
    let networksElement = document.getElementById('networks');
    networksElement.innerHTML = saved ? '<h2>Сохраненные сети</h2>' : '<h2>Доступные сети</h2>';
    data.forEach((network, index) => {
        if (network.ssid) { // Проверка на непустой SSID
            console.log('network', network); // Debug вывод для проверки данных
            let div = document.createElement('div');
            div.innerHTML = `
                <input type="radio" name="network" value="${index}" ${savedSettings.currentIdNetworkSetting === index ? 'checked' : ''} onclick="selectNetworkServer(${index})">
                <strong>SSID:</strong> ${network.ssid}
                <button onclick="deleteNetwork('${network.ssid}')" style="color: red; margin-left: 10px;">❌</button>
            `;

            networksElement.appendChild(div);
        }
    });
}

window.displayNetworks = displayNetworks;

    // Вызываем функцию загрузки настроек при загрузке страницы
    fetchSettings();
})

function deleteNetworkOnClient(ssid) {
    console.log(`Deleting network with SSID ${ssid}`);
    
    // Поиск индекса сети с указанным SSID
    let index = savedSettings.networkSettings.findIndex(network => network.ssid === ssid);
    
    if (index !== -1) { // Проверка, найден ли элемент
        // Удаление из массива
        savedSettings.networkSettings.splice(index, 1);
        
        // Проверка, был ли удаляемый элемент выбранным
        if (savedSettings.currentIdNetworkSetting === index) {
            // Если выбранный элемент был удален, устанавливаем выбор на первый элемент
            savedSettings.currentIdNetworkSetting = 0;
        } else if (savedSettings.currentIdNetworkSetting > index) {
            // Если выбранный элемент находится после удаленного, смещаем индекс выбранного элемента на один назад
            savedSettings.currentIdNetworkSetting--;
        }
        
        // Перерисовка списка сохраненных сетей
        displayNetworks(savedSettings.networkSettings, true);
    } else {
        console.log(`Network with SSID ${ssid} not found`);
    }
}

// Функция для удаления сети по индексу
function deleteNetwork(ssid) {
    var formData = new FormData();
    formData.append('ssid', ssid);
    
    console.log('SSD to delete:', ssid);

    fetch('/deleteNetwork', {
        method: 'POST', // Изменяем метод на POST
        body: formData
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        return response.json();
    })
    .then(data => {
        if (data.success) {
            console.log('Network deleted successfully');
            // Обновление списка сетей на клиенте
          
           deleteNetworkOnClient(ssid);
        } else {
            console.error('Error deleting network:', data.message);
            alert('Failed to delete network');
        }
    })
    .catch(error => {
        console.error('Error deleting network:', error);
        alert('Failed to delete network');
    });
}


// Функция для переключения режима
function toggleMode() {
    var mode = document.querySelector('input[name="mode"]:checked').value;
    if (mode === 'client') {
        document.getElementById('clientSettings').classList.remove('hidden');
        document.getElementById('apSettings').classList.add('hidden');
        document.getElementById('scanButton').classList.remove('hidden');
        document.getElementById('networks').classList.remove('hidden');

    } else {
        document.getElementById('clientSettings').classList.add('hidden');
        document.getElementById('apSettings').classList.remove('hidden');
        document.getElementById('scanButton').classList.add('hidden');
        document.getElementById('networks').classList.add('hidden');
        document.getElementById('staticIPSettings').classList.add('hidden');
    }
}

        function toggleIPMode() {
            var ipMode = document.querySelector('input[name="ip_mode"]:checked').value;
            if (ipMode === 'static') {
                document.getElementById('staticIPSettings').classList.remove('hidden');
            } else {
                document.getElementById('staticIPSettings').classList.add('hidden');
            }
        }

 let isScanning = false;

 function scanWiFi() {
   fetch('/scan', { method: 'POST' })
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            isScanning = true;
        })
        .catch(error => {
            console.error("Error starting WiFi scan:", error);
        });

    var status = document.getElementById('status'); 
    var tmp_status = status.textContent;

    // Начинаем обратный отсчет сразу после отправки запроса
    var countdown = 5;
    var interval = setInterval(() => {
        countdown--;
        if (countdown > 0) {
            status.innerHTML = `<h2>Поиск сетей WIFI... ${countdown} сек.</h2>`;
        } else {
            clearInterval(interval);
            status.innerHTML = `<h2>${tmp_status}</h2>`;
        }
    }, 1000);
}
    

    function displayNetworksScan(data) {
    console.log('NetworksScan', data);
        networks.innerHTML = '<h2>Доступные сети</h2>';
        data.forEach(network => {
            let div = document.createElement('div');
            div.innerHTML = `
                <input type="radio" name="network" value="${network.ssid}" onclick="selectNetwork('${network.ssid}')">
                <strong>SSID:</strong> ${network.ssid} <strong>RSSI:</strong> ${network.rssi}
            `;
            networks.appendChild(div);
        });
    }


    function checkForNetworks() {
    if (!isScanning) return;

    fetch('/getNetworks')
        .then(response => response.json())
        .then(data => {
            if (data && data.length > 0) {
                isScanning = false;
                displayNetworksScan(data);
                document.getElementById('status').innerHTML = "<h2>Сети WIFI найдены</h2>";
            }
        })
        .catch(error => {
            console.error("Error checking for networks:", error);
        });
	}
    
      function selectNetwork(ssid) {
      
   // const networkExists = savedSettings.networkSettings.some(network => network.ssid === ssid);

    //if (!networkExists) {
     document.getElementById('dhcp').checked = true;
      document.getElementById('static').checked = false;
      document.getElementById('staticIPSettings').classList.add('hidden');
    //}

      console.log('selectNetwork', ssid);
        document.getElementById('ssid').value = ssid;
        document.getElementById('connectForm').style.display = 'block';      
      }
  
function applySettings() {

 var statusDiv = document.getElementById("status");

 var isTelegramOn = document.getElementById("isTelegramOn").checked;
    var botId = document.getElementById("botId").value;
    var userList = document.getElementById("userList");
    var rows = userList.getElementsByTagName("tr");
    var users = [];

    for (var i = 0; i < rows.length; i++) {
        var userId = rows[i].cells[0].innerText;
        var reading = rows[i].querySelector("input[name='read']").checked;
        var writing = rows[i].querySelector("input[name='control']").checked;
        users.push({ id: userId, reading: reading, writing: writing });
    }

//=================================
    let mode = document.querySelector('input[name="mode"]:checked').value;
    let currentMode = document.getElementById('currentMode').value;

    let valid = true;

    // Проверка IP адреса
    function validateIP(ip) {
        let parts = ip.split('.');
        if (parts.length !== 4) return false;
        for (let i = 0; i < parts.length; i++) {
            let num = parseInt(parts[i]);
            if (isNaN(num) || num < 0 || num > 255) return false;
        }
        return true;
    }

    // Проверка пароля
    function validatePassword(password) {
        return password.length >= 8;
    }

    // Сброс состояния ошибок
    function resetErrorState(element) {
        element.style.borderColor = '';
    }

    // Установка состояния ошибок
    function setErrorState(element) {
        element.style.borderColor = 'red';
        valid = false;
    }

    let formData = new FormData();
    formData.append('mode', mode);
    
    formData.append('isTelegramOn', isTelegramOn.toString());
    formData.append('botId', botId);
    formData.append('users', JSON.stringify(users));

    for (var pair of formData.entries()) {
       console.log(pair[0] + ': ' + pair[1]);
    }

    if (mode === 'client') {
        let ssid = document.getElementById('ssid').value;
        let password = document.getElementById('password').value;
        let ipMode = document.querySelector('input[name="ip_mode"]:checked').value;
        let selectedNetworkIndex = savedSettings.currentIdNetworkSetting; // Индекс выбранной сети

        if (ssid.trim() === '') {
            setErrorState(document.getElementById('ssid'));
        } else {
            formData.append('ssid', ssid);
            resetErrorState(document.getElementById('ssid'));
        }

        if (false) { // !validatePassword(password)
            setErrorState(document.getElementById('password'));
        } else {
            formData.append('password', password);
            resetErrorState(document.getElementById('password'));
        }

        if (ipMode === 'static') {
            let static_ip = document.getElementById('static_ip').value;
            let gateway = document.getElementById('gateway').value;
            let subnet = document.getElementById('subnet').value;
            let dns = document.getElementById('dns').value;

            if (!validateIP(static_ip)) {
                setErrorState(document.getElementById('static_ip'));
            } else {
                formData.append('static_ip', static_ip);
                resetErrorState(document.getElementById('static_ip'));
            }

            if (!validateIP(gateway)) {
                setErrorState(document.getElementById('gateway'));
            } else {
                formData.append('gateway', gateway);
                resetErrorState(document.getElementById('gateway'));
            }

            if (!validateIP(subnet)) {
                setErrorState(document.getElementById('subnet'));
            } else {
                formData.append('subnet', subnet);
                resetErrorState(document.getElementById('subnet'));
            }

            if (!validateIP(dns)) {
                setErrorState(document.getElementById('dns'));
            } else {
                formData.append('dns', dns);
                resetErrorState(document.getElementById('dns'));
            }
        }

        formData.append('ip_mode', ipMode);
        formData.append('selectedNetworkIndex', selectedNetworkIndex); // Добавляем индекс выбранной сети

    } else {
        let ap_ssid = document.getElementById('ap_ssid').value;
        let ap_password = document.getElementById('ap_password').value;
        let ap_ip = document.getElementById('ap_ip').value;
        let isAP = document.getElementById('is_ap').checked;

        if (ap_ssid.trim() === '') {
            setErrorState(document.getElementById('ap_ssid'));
        } else {
            formData.append('ap_ssid', ap_ssid);
            resetErrorState(document.getElementById('ap_ssid'));
        }

        if (ap_password.trim() !== '' && !validatePassword(ap_password)) {
            setErrorState(document.getElementById('ap_password'));
        } else if (ap_password.trim() !== '') {
            formData.append('ap_password', ap_password);
            resetErrorState(document.getElementById('ap_password'));
        }

        if (ap_ip.trim() !== '' && !validateIP(ap_ip)) {
            setErrorState(document.getElementById('ap_ip'));
        } else if (ap_ip.trim() !== '') {
            formData.append('ap_ip', ap_ip);
            resetErrorState(document.getElementById('ap_ip'));
        }

        formData.append('is_ap', isAP);
    }

    if (valid) {
    	
    	 statusDiv.innerHTML = "Сохранение...";
    
        handleModeChange(mode);

        fetch('/applySettings', {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {

       			 statusDiv.innerHTML = "<br>Настройки успешно сохранены. Чтобы изменения вступили в силу, необходимо перезагрузить устройство.";
                
                // if (tabNameGlobal === 'WiFi') {
//                 	var statusDiv = document.getElementById("status");
//        					 statusDiv.innerHTML = data.message + "<br>Настройки успешно сохранены. Чтобы изменения вступили в силу, необходимо перезагрузить устройство.";
//                 		//updateUI(savedSettings); // Обновляем интерфейс с новыми данными
//                 } else 
//                 	if (tabNameGlobal === 'Telegram') {
//                		  var statusDiv = document.getElementById("statusTelegram");
//        					 statusDiv.innerHTML = data.message + "<br>Чтобы изменения вступили в силу, необходимо перезагрузить устройство.";
//        			 } else 
//                 	if (tabNameGlobal === 'Control') {
//                 		console.log('Selected control tab');
//                 	}
                	
            } else {
                statusDiv.innerHTML = "Ошибка при сохранении настроек!";
            }
        })
        .catch(error => {
            console.error('Ошибка при применении настроек:', error);
            // Обработка смены режима при ошибке
            handleModeChange(mode);
        });
    } else {
        alert('Пожалуйста, исправьте ошибки в форме.');
    }

    function handleModeChange(mode) {
        if (currentMode !== mode) {
            if (mode === 'is_ap') {
                let ap_ssid = document.getElementById('ap_ssid').value;
                document.getElementById('status').innerHTML = `<h2>Статус: Режим работы Wi-Fi изменен. Пожалуйста, переподключитесь к точке доступа: "${ap_ssid}".</h2>`;
            } else {
                let ssid = document.getElementById('ssid').value;
                document.getElementById('status').innerHTML = `<h2>Статус: Режим работы Wi-Fi изменен. Пожалуйста, переподключитесь к Wi-Fi сети: "${ssid}".</h2>`;
            }
            currentMode = mode;
        }
    }
}
//============

document.getElementById('uploadButton').addEventListener('click', function() {
        document.getElementById('fileInput').click(); // Имитация клика по input
    });

    document.getElementById('downloadButton').addEventListener('click', function() {
        var downloadLink = document.getElementById('downloadLink');
        var copyMessage = document.getElementById('copyMessage');
        downloadLink.style.display = 'block';
        copyMessage.style.display = 'block';

        // Копирование ссылки в буфер обмена
        var dummy = document.createElement('input');
        document.body.appendChild(dummy);
        dummy.setAttribute('value', downloadLink.getElementsByTagName('a')[0].href);
        dummy.select();
        document.execCommand('copy');
        document.body.removeChild(dummy);
    });


function uploadFile() {
        var statusHeader = document.getElementById('fileStatus');
        statusHeader.textContent = "Загрузка файла..."; // Статус перед началом загрузки

        var fileInput = document.getElementById('fileInput');
        var file = fileInput.files[0];
        var formData = new FormData();
        formData.append('file', file);

        var fileName = file.name;
        var extension = fileName.substring(fileName.lastIndexOf('.') + 1);

        if (extension === "bin") {
            var countdown = 8;
            statusHeader.textContent = `Обновление... ${countdown} секунд осталось`; // Статус перед успешной загрузкой и начала обновления
            var interval = setInterval(function() {
                countdown--;
                if (countdown > 0) {
                    statusHeader.textContent = `Обновление... ${countdown} секунд осталось`;
                } else {
                    clearInterval(interval);
                    statusHeader.textContent = "Переподключитесь к устройству"; // Сообщение о переподключении
                    setTimeout(function() {
                    checkServerAndReload();
                        
                    }, 3000); // 3 секунды для переподключения
                }
            }, 1000); // Таймер на 1 секунду
        }

        fetch('/uploadFile', {
            method: 'POST',
            body: formData
        })
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.text();
        })
        .then(data => {
            if (extension !== "bin") {
                statusHeader.textContent = "Успешно"; // Статус после успешной загрузки
                location.reload();
            }
        })
        .catch((error) => {
        if (extension !== "bin") {
            console.error('Ошибка:', error);
            statusHeader.textContent = "Ошибка загрузки"; // Статус при ошибке загрузки
            }
        });
    }
    
    function checkServerAndReload() {
        fetch('/', { method: 'HEAD' })
            .then(response => {
                if (response.ok) {
                    location.reload();
                } else {
                    console.error('Сервер недоступен');
                }
            })
            .catch(error => {
                console.error('Ошибка подключения к серверу:', error);
            });
		}
////==========ТЕЛЕГРАМ=============////

function validateBotId(botId) {
    // Регулярное выражение для проверки допустимых символов
    const regex = /^[a-zA-Z0-9_\-:!@#$%^&*()+=<>?]+$/;
    return regex.test(botId);
}


function setBotId() {
    var botId = document.getElementById("botId").value;

    if (!validateBotId(botId)) {
        console.log(botId);
        var statusDiv = document.getElementById("statusTelegram");
        statusDiv.innerHTML = "Invalid Bot ID. Please use only allowed characters.";
        alert("Invalid Bot ID. Please use only allowed characters."); 
        return;
    }

    let formData = new FormData();
    formData.append('botId', botId);
    
    fetch('/set_bot_id', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
//         var statusDiv = document.getElementById("statusTelegram");
//         statusDiv.innerHTML = data.message;

        // Вывод имени бота
        if (data.botName) {
                    var botNameDiv = document.getElementById("statusTelegram");
                    var cleanBotName = data.botName.trim(); // Удаление пробелов

						botNameDiv.textContent = "Bot Name: @" + data.botName;
                }
    })
    .catch(error => {
        console.error("Error:", error);
    });
}


function addUser() {
    var userId = document.getElementById("userId").value;
    // Проверка на пустое поле пользователя
    if (!userId) {
        alert("Введите идентификатор пользователя!");
        return;
    }

    // Проверка на уникальность пользователя
    var userList = document.getElementById("userList");
    var rows = userList.getElementsByTagName("tr");
    for (var i = 0; i < rows.length; i++) {
        if (rows[i].cells[0].innerText === userId) {
            alert("Пользователь с таким идентификатором уже существует!");
            return;
        }
    }

    // Создаем строки таблицы с флажками по умолчанию
    var newRow = document.createElement("tr");
    newRow.innerHTML = `
        <td>${userId}</td>
        <td><input type="checkbox" name="read" checked></td>
        <td><input type="checkbox" name="control" checked></td>
        <td><button onclick="deleteUser('${userId}')">Удалить</button></td>
    `;
    userList.appendChild(newRow);

    document.getElementById("userTable").classList.remove("hidden");

    // Создаем объект FormData и отправляем данные на сервер
    let formData = new FormData();
    formData.append('user_id', userId);
    formData.append('reading', true);
    formData.append('writing', true);

    fetch('/add_user', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        document.getElementById("statusTelegram").innerHTML = data.message;
    })
    .catch(error => {
        console.error('Error adding user:', error);
    });
}

function deleteUser(userId) {
    let formData = new FormData();
    formData.append('user_id', userId);

    fetch('/delete_user', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        console.log('Response from server:', data);

        if (data.success) {
            document.getElementById("statusTelegram").innerHTML = data.message;

            // Ищем строку с указанным userId и удаляем её
            var userList = document.getElementById("userList");
            var rows = userList.getElementsByTagName("tr");
            for (var i = 0; i < rows.length; i++) {
                if (rows[i].cells[0].innerText == userId) {
                    userList.removeChild(rows[i]);
                    break;
                }
            }

            // Проверяем, есть ли еще пользователи после удаления
            if (userList.getElementsByTagName("tr").length === 0) {
                document.getElementById("userTable").classList.add("hidden");
            }
        } else {
            console.error('Server returned error:', data.message);
        }
    })
    .catch(error => {
        console.error('Error deleting user:', error);
    });

    // Предотвращаем переключение на дефолтную вкладку
    event.preventDefault();
}

//=====================
 async function getStatus() {
      try {
        const response = await fetch('/sysStatus'); // Отправляем GET запрос к серверу
        if (!response.ok) throw new Error('Network response was not ok');
        const status = await response.text(); // Получаем текст ответа
        showModal(status); // Отображаем статус в алерте
        // Или можно использовать модальное окно вместо алерта
        // showModal(status); 
      } catch (error) {
        console.error('Ошибка:', error);
        alert('Не удалось получить статус системы.');
      }
    }

  // Функция для отображения модального окна
function showModal(status) {
    const htmlStatus = status.replace(/\n/g, '<br>');

    const modal = document.createElement('div');
    modal.style.position = 'fixed';
    modal.style.top = '50%';
    modal.style.left = '50%';
    modal.style.transform = 'translate(-50%, -50%)';
    modal.style.backgroundColor = 'white';
    modal.style.border = '1px solid black';
    modal.style.padding = '20px';
    modal.style.zIndex = '1000';
    modal.style.width = '300px';

    const text = document.createElement('p');
    text.innerHTML = htmlStatus;
    modal.appendChild(text);

    // Кнопка "Закрыть"
    const closeButton = document.createElement('button');
    closeButton.textContent = 'Закрыть';
    closeButton.onclick = () => document.body.removeChild(modal);
    closeButton.style.marginBottom = '10px';
    modal.appendChild(closeButton);

    // Ссылка "Сбросить настройки"
    const resetLink = document.createElement('a');
    resetLink.textContent = 'Сбросить настройки';
    resetLink.href = '#';
    resetLink.style.display = 'block'; // Ссылка на отдельной строке
    resetLink.style.marginTop = '10px';
    resetLink.style.textDecoration = 'underline';
    resetLink.style.color = 'blue';
    resetLink.onclick = (e) => {
        e.preventDefault(); // Предотвращаем переход по ссылке
        const confirmation = confirm('Вы уверены, что хотите сбросить все настройки?');
        if (confirmation) {
            format(); // Вызов функции для сброса настроек
        }
    };
    modal.appendChild(resetLink);

    // // Ссылка "Получить файлы"
//     const fetchFilesLink = document.createElement('a');
//     fetchFilesLink.textContent = 'Получить файлы';
//     fetchFilesLink.href = '#';
//     fetchFilesLink.style.display = 'block'; // Ссылка на отдельной строке
//     fetchFilesLink.style.marginTop = '5px';
//     fetchFilesLink.style.textDecoration = 'underline';
//     fetchFilesLink.style.color = 'blue';
//     fetchFilesLink.onclick = (e) => {
//         e.preventDefault(); // Предотвращаем переход по ссылке
//         fetchFileList(); // Вызов функции для получения файлов
//     };
//     modal.appendChild(fetchFilesLink);

    document.body.appendChild(modal);
}




document.addEventListener('DOMContentLoaded', () => {
 	
    setInterval(updateStates, 1000);

    setInterval(checkForNetworks, 1000);
});
//ver2.5
// получение сертификата openssl s_client -showcerts -connect api.telegram.org:443 </dev/null 2>/dev/null | openssl x509 -outform PEM > api_telegram_org.pem 
    </script>
    
    <input type="hidden" id="currentMode" value="">
  </body>
  </html>